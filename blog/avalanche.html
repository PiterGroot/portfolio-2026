<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tab title</title>
    <link rel="stylesheet" href="../style/styles.css">
    <link rel="stylesheet" href="../style/blog-style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
</head>

<body>
    <div id="particles-js"></div>
    <script src="../js/particles.js"></script>
    <script src="../js/app.js"></script>
    <script src="../js/smooth-scroll.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/"></script>

    <div class="blog-post-container">
        <a href="../index.html" class="back-link">‚Üê Back</a>

        <article>
            <header class="blog-post-header">
                <h1 class="blog-post-title">Building Avalanche: A C++ Falling Sand Engine Engine</h1>
                <p class="blog-post-meta">January 7, 2026</p>
            </header>

            <div class="blog-post-content">
                
                <h2>Introduction</h2>
                <p>
                    Ever played the game <a href="https://noitagame.com/">Noita?</a> I have, and I love it. In Noita, every pixel on the screen is simulated in the physics engine called <a href="https://nollagames.com/fallingeverything/">the falling everything engine</a>.
                    It is a very impressive falling sand engine and as part of my school assignment, I was inspired to build my own falling sand engine/library.
                </p>
                 
                <p style="text-align: center;"><img src="../media/noita.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p> 
                    That's why I started working on Avalanche, a production-ready falling sand physics engine designed as a single-header C++ library. The goal was to create a fast, flexible system to simulate thousands of particles on the CPU that developers could integrate into their projects with minimal friction. In Avalanche, all cell behaviors are user-definable via a clean API, allowing for easy extension and customization. 
                    
                    <br><br>Here is a video showcasing some of the behaviors that can be simulated using the API.
                </p>

                <video src="../media/showcase.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <h2>What is a falling sand simulation?</h2>
                <p>
                    Falling sand simulations are a type of cellular automaton where each cell in a grid represents a particle or empty space. The simulation updates the state of each cell based on predefined rules that dictate how particles interact with each other and their environment. Common behaviors include falling due to gravity, spreading out when they hit the ground, and interacting with other particle types (e.g., water flowing around sand).
                    
                    <p style="text-align: center;"><img src="../media/sand_simulation.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>
                    <p style="text-align: center; font-size: smaller; font-style: italic;">GIF by John Jackson | <a href="https://noitagame.com/">Recreating Noita's Sand Simulation in C and OpenGL | Game Engineering</a></p>
                    
                    That being said, falling sand simulations are deceptively complex. It is relatively easy to set-up a mediocre falling sand sim but there are a lot of considerations to make in order to maintain flexible and performant. You potentially need to update thousands of cells every frame, handle spatial queries efficiently, and in my case I will also ideally need to provide a clean API that doesn't get in the way.
                </p>

                <h2>The naive approach</h2>
                <p> 
                    My first attempt was to update every cell sequentially without any chunking or whatnot, this approach had some major issues. There were big performance bottlenecks and arguably more importantly, there was non-deterministic behavior that broke the simulation because of directional biases.
                </p>

                <pre><code class="language-cpp">
if (shouldUpdate)
{
    for (int x = 0; x < WIDTH; x++)
    {
        for (int y = 0; y < HEIGHT - 1; y++)
        {
            UpdateCell(x, y);
        }
    }
}
                </code></pre>

                <p style="text-align: center;"><img src="../media/left-bias.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p>
                    The directional bias issue arose because I was updating cells in a fixed order (top to bottom, left to right). This meant that cells processed earlier in the update cycle had an advantage over those processed later, leading to unrealistic behavior. In this case, particles would consistently fall to the left side of the screen because they were updated before those on the right. This was really evident in the first iteration of Avalanche as you can see above.
                </p>

                <p>
                    Performance was another major concern. Updating every cell in a large grid every frame was computationally expensive, leading to low frame rates and a poor user experience. As the number of particles increased, the performance degraded significantly, making it impractical for real-time applications.
                </p>

                <h2>Improving the simulation</h2>      

                <p>To address these issues, I took a step back and re-evaluated my approach.</p>

                <h3>Solving directional bias</h3>
                <p>
                    After researching some other falling sand projects online, I found that most of them used two main ways to address directional bias: double buffering or randomizing the update order.
                </p>

                
                <h4>1. Randomizing the update direction order</h4>
                 <p style="text-align: center;"><img src="../media/randomized-update-order.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>
                    <p style="text-align: center; font-size: smaller; font-style: italic;">GIF from 
Games Now! | <a href="https://www.youtube.com/watch?v=Mr3E_voEG8Y">Nolla Games: Making of Noita</a></p>
                
                <p>
                    This solution involves shuffling the order in which cells are updated each frame. By randomizing the update sequence, no single direction consistently gets priority, leading to a more balanced and realistic simulation. This method is relatively simple to implement and can significantly reduce directional bias. However, it may introduce some variability in the simulation results, which might not be desirable in all scenarios. This solution is actually used in Noita's falling everything engine as shown in the GIF above, which I was surprised to learn because of the simplicity of this solution.
                </p>

                <h4>1. Double buffering</h4>
                <video src="../media/double-buffer.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <p>
                    This solution involves keeping track of a "desired" moves buffer in addition to the main simulation grid. During each update cycle, cells determine their desired moves based on their current state and the states of neighboring cells, and write these desired moves to the buffer. Once all cells have been processed, the simulation applies the desired moves from the buffer to the main grid in a separate pass. This approach ensures that all cells are updated based on the same initial state, eliminating directional bias. It is a bit more complex to implement than randomizing the update order, but it could provide more consistent results without having to mess with the update order.
                </p>

                <p>
                    I needed to think of a solution that could traverse and process the simulation grid in a way that gave every cell a "fair" chance to move to it's desired position. I came across Winter Dev's <a href="https://winter.dev/articles/falling-sand"> falling sand project</a> and was inspired by his solution for this problem.
                </p>

                <pre><code class="language-cpp">for (int i = 0; i &lt; activeChunks.size(); i++)
{
    SectorChunk* chunk = activeChunks[i];

    for (int x = 0; x &lt; chunk-&gt;chunkSize; x++)
    {
        for (int y = 0; y &lt; chunk-&gt;chunkSize; y++)
        {
            int xPos = x + chunk-&gt;chunkX;
            int yPos = y + chunk-&gt;chunkY;

            Cell* cell = GetCell(xPos, yPos);

            if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_DOWN &amp;&amp; MoveDown(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_UP &amp;&amp; MoveUp(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::FLOAT_UP &amp;&amp; FloatUp(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_DOWN_SIDE &amp;&amp; MoveSideDown(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_SIDE &amp;&amp; MoveSide(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_LEFT &amp;&amp; MoveLeft(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_RIGHT &amp;&amp; MoveRight(xPos, yPos, chunk, cell)) {}
        }
    }
}</code></pre>

                <p>
                    Additionally, I implemented a proper chunking system. I chose a chunk size of 50x50 cells. In Avalanche, chunks are essentially only containers, they do not have any information about the amount of type of cells they contain. They can only be active or be asleep.     This significantly reduced the number of checks I needed to do per frame and improved overall performance.
                </p>

                <video src="../media/chunking.mp4" controls loop style="max-width: 100%; height: auto;"></video>

            </div>
        </article>
    </div>
</body>

</html>