<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tab title</title>
    <link rel="stylesheet" href="../style/styles.css">
    <link rel="stylesheet" href="../style/blog-style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
</head>

<body>
    <div id="particles-js"></div>
    <script src="../js/particles.js"></script>
    <script src="../js/app.js"></script>
    <script src="../js/smooth-scroll.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/"></script>

    <div class="blog-post-container">
        <a href="../index.html" class="back-link">‚Üê Back</a>

        <article>
            <header class="blog-post-header">
                <h1 class="blog-post-title">Building Avalanche: A C++ Falling Sand Engine Engine</h1>
                <p class="blog-post-meta">January 7, 2026</p>
            </header>

            <div class="blog-post-content">
                
                <h2>Introduction</h2>
                <p>
                    Ever played the game <a href="https://noitagame.com/">Noita?</a> I have, and I love it. In Noita, every pixel on the screen is simulated in the physics engine called <a href="https://nollagames.com/fallingeverything/">the falling everything engine</a>.
                    It is a very impressive falling sand engine and as part of my school assignment, I was inspired to build my own falling sand engine/library.
                </p>
                 
                <p style="text-align: center;"><img src="../media/noita.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p> 
                    That's why I started working on Avalanche, a production-ready falling sand physics engine designed as a single-header C++ library. The goal was to create a fast, flexible system to simulate thousands of particles on the CPU that developers could integrate into their projects with minimal friction. In Avalanche, all cell behaviors are user-definable via a clean API, allowing for easy extension and customization. 
                    
                    <br><br>Here is a video showcasing some of the behaviors that can be simulated using the API.
                </p>

                <video src="../media/showcase.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <h2>What is a falling sand simulation?</h2>
                <p>
                    Falling sand simulations are a type of cellular automaton where each cell in a grid represents a particle or empty space. The simulation updates the state of each cell based on predefined rules that dictate how particles interact with each other and their environment. Common behaviors include falling due to gravity, spreading out when they hit the ground, and interacting with other particle types (e.g., water flowing around sand).
                    
                    <p style="text-align: center;"><img src="../media/sand_simulation.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>
                    <p style="text-align: center; font-size: smaller; font-style: italic;">GIF by John Jackson | <a href="https://noitagame.com/">Recreating Noita's Sand Simulation in C and OpenGL | Game Engineering</a></p>
                    
                    That being said, falling sand simulations are deceptively complex. It is relatively easy to set-up a mediocre falling sand sim but there are a lot of considerations to make in order to maintain flexible and performant. You potentially need to update thousands of cells every frame, handle spatial queries efficiently, and in my case I will also ideally need to provide a clean API that doesn't get in the way.
                </p>

                <h2>The naive approach</h2>
                <p> 
                    My first attempt was to update every cell sequentially, but this approach had some major issues. There were big performance bottlenecks and arguably more importantly, there was non-deterministic behavior that broke the simulation because of directional biases.
                </p>

                <p style="text-align: center;"><img src="../media/left-bias.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p>
                    The directional bias issue arose because I was updating cells in a fixed order (top to bottom, left to right). This meant that cells processed earlier in the update cycle had an advantage over those processed later, leading to unrealistic behavior. In this case, particles would consistently fall to the left side of the screen because they were updated before those on the right. This was really evident in the first iteration of Avalanche as you can see above.
                </p>

                <h2>Improving the simulation</h2>                
                <p>
                    To address these issues, I took a step back and re-evaluated my approach. I implemented a few key changes, one of them was double buffering the simulation state. This meant maintaining two copies of the grid: one for reading the current state and another for writing the updated state. By doing this, I ensured that all cells were updated based on the same initial conditions, eliminating directional biases.
                </p>

                <pre><code class="language-cpp">for (int i = 0; i &lt; activeChunks.size(); i++)
{
    SectorChunk* chunk = activeChunks[i];

    for (int x = 0; x &lt; chunk-&gt;chunkSize; x++)
    {
        for (int y = 0; y &lt; chunk-&gt;chunkSize; y++)
        {
            int xPos = x + chunk-&gt;chunkX;
            int yPos = y + chunk-&gt;chunkY;

            Cell* cell = GetCell(xPos, yPos);

            if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_DOWN &amp;&amp; MoveDown(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_UP &amp;&amp; MoveUp(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::FLOAT_UP &amp;&amp; FloatUp(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_DOWN_SIDE &amp;&amp; MoveSideDown(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_SIDE &amp;&amp; MoveSide(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_LEFT &amp;&amp; MoveLeft(xPos, yPos, chunk, cell)) {}
            else if (cell-&gt;MoveFlags &amp; CellMoveFlags::MOVE_RIGHT &amp;&amp; MoveRight(xPos, yPos, chunk, cell)) {}
        }
    }
}</code></pre>

                <p>
                    Additionally, I reworked the cell update batching so that it now only processes active cells inside chunks (those that contain particles) and their immediate neighbors. This significantly reduced the number of checks I needed to do per frame and improved overall performance.
                </p>

                <video src="../media/chunking.mp4" controls loop style="max-width: 100%; height: auto;"></video>

            </div>
        </article>
    </div>
</body>

</html>