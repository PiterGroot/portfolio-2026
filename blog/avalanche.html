<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tab title</title>
    <link rel="stylesheet" href="../style/styles.css">
    <link rel="stylesheet" href="../style/blog-style.css">
</head>

<body>
    <div id="particles-js"></div>
    <script src="../js/particles.js"></script>
    <script src="../js/app.js"></script>
    <script src="../js/smooth-scroll.js"></script>

    <div class="blog-post-container">
        <a href="../index.html" class="back-link">‚Üê Back</a>

        <article>
            <header class="blog-post-header">
                <h1 class="blog-post-title">Building Avalanche: A C++ Falling Sand Engine Engine</h1>
                <p class="blog-post-meta">January 7, 2026</p>
            </header>

            <div class="blog-post-content">
                
                <h2>Introduction</h2>
                <p>
                    Ever played the game <a href="https://noitagame.com/">Noita?</a> I have, and I love it. In Noita, every pixel on the screen is simulated in the physics engine called <a href="https://nollagames.com/fallingeverything/">the falling everything engine</a>.
                    It is a very impressive falling sand engine and as part of my school assignment, I was inspired to build my own fallling sand engine/library.
                </p>
                 
                <p style="text-align: center;"><img src="../media/noita.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p> 
                    That's why I started working on Avalanche, a production-ready falling sand physics engine designed as a single-header C++ library. The goal was to create a fast, flexible system to simulate thousands of particles on the CPU that developers could integrate into their projects with minimal friction. In Avalanche, all cell behaviors are user-definable via a clean API, allowing for easy extension and customization. 
                    
                    <br><br>Here is a video showcaing some of the behaviors that can be simulated using the API.
                </p>

                <video src="../media/showcase.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <p>
                    Falling sand simulations are deceptively complex. You potentially need to update thousands of cells every frame, handle spatial queries efficiently, and in my case I will also idealy need to provide a clean API that doesn't get in the way.
                </p>

                <h2>The naive approach</h2>
                <p> 
                    My first attempt was to update every cell sequentially, but this approach had some major issues. There were big performance bottlenecks and arguably more important, non-deterministic behavior that broke the simulation because of directional biases.
                </p>

                <p style="text-align: center;"><img src="../media/left-bias.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p>
                    The directional bias issue arose because I was updating cells in a fixed order (top to bottom, left to right). This meant that cells processed earlier in the update cycle had an advantage over those processed later, leading to unrealistic behavior. In this case, particles would consistently fall to the left side of the screen because they were updated before those on the right. This was really evident in the first itteration of Avalanche as you can see above.
                </p>

            </div>
        </article>
    </div>
</body>

</html>