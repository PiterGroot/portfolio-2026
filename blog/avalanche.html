<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tab title</title>
    <link rel="stylesheet" href="../style/styles.css">
    <link rel="stylesheet" href="../style/blog-style.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-okaidia.min.css">

</head>

<body>
    <div id="particles-js"></div>
    <div class="blog-post-container">
        <a href="../index.html" class="back-link">‚Üê Back</a>

        <article>
            <header class="blog-post-header">
                <h1 class="blog-post-title">Building Avalanche: A C++ Falling Sand Engine Engine</h1>
                <p class="blog-post-meta">January 7, 2026</p>
            </header>

            <div class="blog-post-content">
                
                <h2>Introduction</h2>
                <p>
                    Ever played the game <a href="https://noitagame.com/">Noita?</a> I have, and I love it. In Noita, every pixel on the screen is simulated in the physics engine called <a href="https://nollagames.com/fallingeverything/">the falling everything engine</a>.
                    It is a very impressive falling sand engine and as part of my school assignment, I was inspired to build my own falling sand engine/library.
                </p>
                 
                <p style="text-align: center;"><img src="../media/noita.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>

                <p> 
                    That's why I started working on Avalanche, a production-ready falling sand physics engine designed as a single-header C++ library. The goal was to create a fast, flexible system to simulate thousands of particles on the CPU that developers could integrate into their projects with minimal friction. In Avalanche, all cell behaviors are user-definable via a clean API, allowing for easy extension and customization. 
                    
                    <br><br>Here is a video showcasing some of the behaviors that can be simulated using the API.
                </p>

                <video src="../media/showcase.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <h2>What is a falling sand simulation?</h2>
                <p>
                    Falling sand simulations are a type of cellular automaton where each cell in a grid represents a particle or empty space. The simulation updates the state of each cell based on predefined rules that dictate how particles interact with each other and their environment. Common behaviors include falling due to gravity, spreading out when they hit the ground, and interacting with other particle types (e.g., water flowing around sand).
                    
                    <p style="text-align: center;"><img src="../media/sand_simulation.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>
                    <p style="text-align: center; font-size: smaller; font-style: italic;">GIF by John Jackson | <a href="https://noitagame.com/">Recreating Noita's Sand Simulation in C and OpenGL | Game Engineering</a></p>
                    
                    That being said, falling sand simulations are deceptively complex. It is relatively easy to set-up a mediocre falling sand sim but there are a lot of considerations to make in order to maintain flexible and performant. You potentially need to update thousands of cells every frame, handle spatial queries efficiently, and in my case I will also ideally need to provide a clean API that doesn't get in the way.
                </p>

                <h2>The naive approach</h2>
                <p> 
                    My first attempt was to update every cell sequentially without any chunking or whatnot, this approach had some major issues. There were big performance bottlenecks and arguably more importantly, there was non-deterministic behavior that broke the simulation because of directional biases.
                </p>

                <video src="../media/left-bias.mp4" controls loop style="max-width: 100%; height: auto;"></video>
                <p style="text-align: center; font-size: smaller; font-style: italic;">Intense left-bias in first iteration of the simulation.</p>

                <pre><code class="language-cpp">
if (shouldUpdate)
{
    for (int x = 0; x < WIDTH; x++)
    {
        for (int y = 0; y < HEIGHT - 1; y++)
        {
            UpdateCell(x, y);
        }
    }
}
                </code></pre>

                <p>
                    The directional bias issue arose because I was updating cells in a fixed order (top to bottom, left to right). This meant that cells processed earlier in the update cycle had an advantage over those processed later, leading to unrealistic behavior. In this case, particles would consistently fall to the left side of the screen because they were updated before those on the right. This was really evident in the first iteration of Avalanche as you can see above.
                </p>

                <p>
                    Performance was another major concern. Updating every cell in a large grid every frame was computationally expensive, leading to low frame rates and a poor user experience. As the number of particles increased, the performance degraded significantly, making it impractical for real-time applications.
                </p>

                <h2>Improving the simulation</h2>      

                <p>To address these issues, I took a step back and re-evaluated my approach.</p>

                <h3>Solving directional bias</h3>
                <p>
                    After researching some other falling sand projects online, I found that most of them used two main ways to address directional bias: double buffering or randomizing the update order.
                </p>

                
                <h4>1. Randomizing the update direction order</h4>
                 <p style="text-align: center;"><img src="../media/randomized-update-order.gif" alt="Noita" style="max-width: 100%; height: auto;"></p>
                    <p style="text-align: center; font-size: smaller; font-style: italic;">GIF from 
Games Now! | <a href="https://www.youtube.com/watch?v=Mr3E_voEG8Y">Nolla Games: Making of Noita</a></p>
                
                <p>
                    This solution involves shuffling the order in which cells are updated each frame and processing cells one by one one immediately as they are updated. By randomizing the update sequence, no single direction consistently gets priority, leading to a more balanced and realistic simulation. This method is relatively simple to implement and can significantly reduce directional bias. However, it may introduce some variability in the simulation results because the cells are immediately processed before taking all other cells a fair chance, which might not be desirable in all scenarios. This solution is actually used in Noita's falling everything engine as shown in the GIF above, which I was surprised to learn because of the simplicity of this solution.
                </p>

                <h4>2. Double buffering</h4>
                <video src="../media/double-buffer.mp4" controls loop style="max-width: 100%; height: auto;"></video>

                <p>
                    This solution involves keeping track of a "desired" moves buffer in addition to the main simulation grid. During each update cycle, cells determine their desired moves based on their current state and the states of neighboring cells, and write these desired moves to the buffer. Once all cells have been processed, the simulation applies the desired moves from the buffer to the main grid in a separate pass. This approach ensures that all cells are updated based on the same initial state, eliminating directional bias. It is a bit more complex to implement than randomizing the update order, but it could provide more consistent results without having to mess with the update order.
                </p>

                <p>
                    After carefully considering both options, I decided to implement the double buffering approach in Avalanche. I felt that it would provide a more robust solution to the directional bias issue while also allowing for greater control over the simulation's behavior and the other option feels more like a band aid solution that is not actually tackling the problem at hand.
                </p>

                <pre><code class="language-cpp">void SimulationSector::_commit_cells()
{
	std::sort(std::execution::par, _cellChanges.begin(), _cellChanges.end(),
		[](auto& a, auto& b) { return a.first < b.first; });

	size_t iprev = 0;
	_cellChanges.emplace_back(-1, -1);

	for (size_t i = 0; i < _cellChanges.size() - 1; i++)
	{
		if (_cellChanges[i].first != _cellChanges[i + 1].first)
		{
			size_t rand = iprev + avl::utils::get_random_value(0, (int)(i - iprev));

			size_t dst = _cellChanges[rand].first;
			size_t src = _cellChanges[rand].second;

			_set_cell_info
			(
				dst,
				_activeCellIDs[src],
				_activeCellColors[src],
				_activeCellsUserData[src]
			);

			_set_cell_info(src, 0, 0, 0);

			iprev = i + 1;
		}
	}

	_cellSwaps.clear();
	_cellChanges.clear();
}</code></pre>
                <p>
                    The code snippet above shows how I implemented the commit phase of the double buffering system in Avalanche. During the update phase, each cell's desired move is recorded in the _cellChanges vector as a pair of source and destination indices. In the commit phase, I first sort the _cellChanges vector to group all changes targeting the same destination together. <br><br>Then, I iterate through the sorted changes, and for each unique destination, I randomly select one of the source cells that want to move there. This randomness helps to further reduce any residual bias that might occur when multiple cells target the same destination. The selected cell's information is then applied to the destination, and the source cell is cleared. Finally, I clear the _cellSwaps and _cellChanges vectors to prepare for the next update cycle.
                </p>

                 <h3>Adding a proper chunking framework</h3>
                 <p>It is very wasteful to loop over all cells in a sector every frame, especially when many of them are inactive. To optimize this, I implemented a chunking system where the sector (a single grid of 500x500 cells) is divided into smaller chunks of 50x50 cells. Only active chunks are processed each frame, significantly reducing the number of cells that need to be checked. Chunks themselves don't know anything about how many cell they contain or what type of cells they are. Chunks are just containers that can be active or asleep. This significantly reduced the number of checks I needed to do per frame and improved overall performance.</p>
                 
                <pre><code class="language-cpp">for (int i = 0; i &lt; activeChunks.size(); i++)
{
    SectorChunk* chunk = activeChunks[i];

    for (int x = 0; x &lt; chunk-&gt;chunkSize; x++)
    {
        for (int y = 0; y &lt; chunk-&gt;chunkSize; y++)
        {
            int xPos = x + chunk-&gt;chunkX;
            int yPos = y + chunk-&gt;chunkY;

            Cell* cell = GetCell(xPos, yPos);

            // Process cell behavior here.
        }
    }
}</code></pre>

                <video src="../media/chunking.mp4" controls loop style="max-width: 100%; height: auto;"></video>
                <p style="text-align: center; font-size: smaller; font-style: italic;">Video showcasing double buffering and chunking implementation. Notice there is no directional bias anymore.</p>


            </div>
        </article>
    </div>

<script src="../js/particles.js"></script>
<script src="../js/app.js"></script>
<script src="../js/smooth-scroll.js"></script>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script>
    window.addEventListener('load', function() {
        Prism.highlightAll();
    });
</script>


</body>

</html>

<!-- Reference links for later: -->
<!-- I came across Winter Dev's <a href="https://winter.dev/articles/falling-sand"> falling sand project</a> and was inspired by his solution for this problem. -->